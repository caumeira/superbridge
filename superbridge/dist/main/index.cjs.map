{"version":3,"file":"index.cjs","sources":["../../utils/Signal.ts","../../shared/superbridge.ts","../../shared/defineMessage.ts","../../utils/id.ts","../../shared/serializer/abortSignal.ts","../../shared/log.ts","../../shared/serializer/callbacks.ts","../../shared/serializer/index.ts","../../__vite-browser-external","../../../node_modules/electron/index.js","../../utils/controlledPromise.ts","../../shared/channel.ts","../../main/init.ts","../../shared/messages.ts","../../main/initializeBridge.ts","../../main/query.ts","../../main/effect.ts","../../main/mutation.ts","../../utils/nestedRecord.ts","../../main/schema.ts","../../main/BridgeHandler.ts"],"sourcesContent":["type Listener<T> = (value: T) => void;\n\ntype Cleanup = () => void;\n\nconst NO_VALUE = Symbol(\"NO_VALUE\");\n\nexport class Signal<T> {\n  private listeners = new Map<Symbol, Listener<T>>();\n  private lastValue: T | typeof NO_VALUE = NO_VALUE;\n\n  assertLastValue(error: Error | string) {\n    if (this.lastValue === NO_VALUE) {\n      throw typeof error === \"string\" ? new Error(error) : error;\n    }\n\n    return this.lastValue;\n  }\n\n  get hasLastValue() {\n    return this.lastValue !== NO_VALUE;\n  }\n\n  get maybeLastValue() {\n    return this.lastValue === NO_VALUE ? undefined : this.lastValue;\n  }\n\n  emit(value: T) {\n    this.lastValue = value;\n\n    const listeners = [...this.listeners.values()];\n\n    for (const listener of listeners) {\n      try {\n        listener(value);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n\n  subscribe(listener: Listener<T>) {\n    const id = Symbol();\n\n    this.listeners.set(id, listener);\n\n    return () => {\n      this.listeners.delete(id);\n    };\n  }\n\n  subscribeWithCurrentValue(listener: Listener<T>) {\n    if (this.lastValue !== NO_VALUE) {\n      listener(this.lastValue);\n    }\n\n    return this.subscribe(listener);\n  }\n\n  effect(initializer: (value: T) => Cleanup) {\n    let currentCleanup: Cleanup | undefined;\n\n    const cancelSubscription = this.subscribeWithCurrentValue((value) => {\n      if (currentCleanup) {\n        currentCleanup();\n      }\n\n      currentCleanup = initializer(value);\n    });\n\n    return () => {\n      cancelSubscription();\n\n      if (currentCleanup) {\n        currentCleanup();\n      }\n    };\n  }\n}\n","import { BridgeMessageType } from \"./defineMessage\";\nimport { Signal } from \"../utils/Signal\";\n\ntype Cancel = () => void;\n\nexport interface SuperbridgeLink {\n  send<I, O>(\n    message: BridgeMessageType<I, O>,\n    payload: I,\n    webId?: number\n  ): Promise<O>;\n\n  handle<I, O>(\n    message: BridgeMessageType<I, O>,\n    handler: (payload: I) => Promise<O>\n  ): Cancel;\n}\n\nconst currentSuperbridgeChannel = new Signal<SuperbridgeLink>();\n\nexport function initializeSuperbridge(superbridge: SuperbridgeLink) {\n  currentSuperbridgeChannel.emit(superbridge);\n}\n\nexport const bridge: SuperbridgeLink = {\n  send<I, O>(message: BridgeMessageType<I, O>, payload: I, webId?: number) {\n    const link = currentSuperbridgeChannel.assertLastValue(\n      \"Superbridge is not initialized\"\n    );\n\n    return link.send(message, payload, webId);\n  },\n  handle<I, O>(\n    message: BridgeMessageType<I, O>,\n    handler: (payload: I) => Promise<O>\n  ) {\n    if (!currentSuperbridgeChannel.hasLastValue) {\n      Promise.resolve().then(() => {\n        if (!currentSuperbridgeChannel.hasLastValue) {\n          console.warn(\"Superbridge is not initialized\");\n        }\n      });\n    }\n    return currentSuperbridgeChannel.effect((currentBridge) => {\n      return currentBridge.handle(message, handler);\n    });\n  },\n};\n","export class BridgeMessageType<I, O> {\n  constructor(public readonly type: string) {}\n\n  input!: I;\n  output!: O;\n}\n\nexport function defineBridgeMessage<I, O = void>(\n  name: string\n): BridgeMessageType<I, O> {\n  return new BridgeMessageType<I, O>(name);\n}\n","const ALPHABET =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\nexport function generateId(length: number = 12) {\n  let id = \"\";\n\n  for (let i = 0; i < length; i++) {\n    id += ALPHABET[Math.floor(Math.random() * ALPHABET.length)];\n  }\n\n  return id;\n}\n","import { CustomTransfomer } from \"./types\";\nimport { bridge } from \"../superbridge\";\nimport { defineBridgeMessage } from \"../defineMessage\";\nimport { generateId } from \"../../utils/id\";\n\nconst signalRemoteController = new Map<string, AbortController>();\n\nexport const $abortRemoteSignal = defineBridgeMessage<{\n  signalId: string;\n}>(\"$abortRemoteSignal\");\n\nexport function registerSignal(localSignal: AbortSignal) {\n  const id = `$$signal-${generateId()}`;\n  const remoteController = new AbortController();\n\n  signalRemoteController.set(id, remoteController);\n\n  // If local signal is aborted, abort the remote one\n  localSignal.addEventListener(\"abort\", () => {\n    bridge.send($abortRemoteSignal, { signalId: id });\n    signalRemoteController.delete(id);\n  });\n\n  signalFinalizationRegistry.register(localSignal, id);\n\n  return id;\n}\n\nbridge.handle($abortRemoteSignal, async ({ signalId }) => {\n  const controller = signalRemoteController.get(signalId);\n\n  if (!controller) return;\n\n  controller.abort();\n  signalRemoteController.delete(signalId);\n});\n\nconst signalFinalizationRegistry = new FinalizationRegistry<string>(\n  (remoteSignalId) => {\n    const controller = signalRemoteController.get(remoteSignalId);\n\n    if (!controller) return;\n\n    controller.abort();\n    signalRemoteController.delete(remoteSignalId);\n  }\n);\n\nfunction deserializeSignalId(signalId: string): AbortSignal {\n  const controller = new AbortController();\n\n  signalRemoteController.set(signalId, controller);\n\n  return controller.signal;\n}\n\nexport const abortSignalSerializer: CustomTransfomer<AbortSignal, string> = {\n  isApplicable: (value): value is AbortSignal => value instanceof AbortSignal,\n  serialize: (signal: AbortSignal) => registerSignal(signal),\n  deserialize: (signalId: string) => deserializeSignalId(signalId),\n};\n","type Log = (...args: any[]) => void;\n\ninterface Logger {\n  (...args: any[]): void;\n  debug: Log;\n  warn: Log;\n  error: Log;\n  rename: (name: string) => Logger;\n}\n\nexport function createLogger(name: string): Logger {\n  const LOG_COLOR = \"#808080\";\n  const LOG_STYLE = `color: ${LOG_COLOR};`;\n\n  const LABEL = `%cðŸŒ‰ ${name}:%c`;\n\n  const log: Logger = (...args) => {\n    console.info(LABEL, LOG_STYLE, \"\", ...args);\n  };\n\n  log.debug = (...args) => {\n    console.debug(LABEL, LOG_STYLE, \"\", ...args);\n  };\n\n  log.warn = (...args) => {\n    console.warn(LABEL, LOG_STYLE, \"\", ...args);\n  };\n\n  log.error = (...args) => {\n    console.error(LABEL, LOG_STYLE, \"\", ...args);\n  };\n\n  log.rename = (name: string) => {\n    return createLogger(name);\n  };\n\n  return log;\n}\n\nexport const log = createLogger(\"superbridge\");\n","import { CustomTransfomer } from \"./types\";\nimport { bridge } from \"../superbridge\";\nimport { createLogger } from \"../log\";\nimport { defineBridgeMessage } from \"../defineMessage\";\nimport { generateId } from \"../../utils/id\";\n\nconst log = createLogger(\"superbridge/callbacks\");\n\nconst callbacks = new Map<string, Function>();\n\nexport const $removeRemoteCallback = defineBridgeMessage<{\n  callbackId: string;\n}>(\"$removeRemoteCallback\");\n\nexport const $triggerRemoteCallback = defineBridgeMessage<\n  {\n    callbackId: string;\n    args: unknown[];\n  },\n  unknown\n>(\"$triggerRemoteCallback\");\n\nbridge.handle($removeRemoteCallback, async ({ callbackId }) => {\n  log.debug(`Handling remove remote callback \"${callbackId}\"`);\n  callbacks.delete(callbackId);\n});\n\nbridge.handle($triggerRemoteCallback, async ({ callbackId, args }) => {\n  log.debug(\n    `Handling trigger remote callback \"${callbackId}\" with callId`,\n    args\n  );\n  const callback = callbacks.get(callbackId);\n\n  if (!callback) {\n    throw new Error(`Callback \"${callbackId}\" not found`);\n  }\n\n  return await callback(...args);\n});\n\nfunction getCallbackId() {\n  let id = `$$callback-${generateId()}`;\n\n  if (typeof window !== \"undefined\") {\n    id = `${id}-${window.$superbridgeinterface.routingId}`;\n  }\n\n  return id;\n}\n\n/**\n * $$callback-123-456\n */\nfunction getCallbackRoutingId(callbackId: string) {\n  const [_callbackLabel, _callbackId, routingId] = callbackId.split(\"-\");\n\n  if (!routingId) return null;\n\n  return parseInt(routingId, 10);\n}\n\nexport function registerCallback(callback: Function) {\n  const id = getCallbackId();\n\n  callbacks.set(id, callback);\n\n  return id;\n}\n\nconst callbackFinalizationRegistry = new FinalizationRegistry<string>(\n  (remoteCallbackId) => {\n    bridge.send(\n      $removeRemoteCallback,\n      { callbackId: remoteCallbackId },\n      getCallbackRoutingId(remoteCallbackId) ?? undefined\n    );\n  }\n);\n\nfunction deserializeCallbackId(callbackId: string) {\n  async function remoteCallbackInvoker(...args: unknown[]) {\n    log.debug(`Invoking remote callback \"${callbackId}\" with args`, args);\n\n    return await bridge.send(\n      $triggerRemoteCallback,\n      {\n        callbackId: callbackId,\n        args,\n      },\n      getCallbackRoutingId(callbackId) ?? undefined\n    );\n  }\n\n  callbackFinalizationRegistry.register(remoteCallbackInvoker, callbackId);\n\n  return remoteCallbackInvoker;\n}\n\nexport const callbackSerializer: CustomTransfomer<Function, string> = {\n  isApplicable: (value): value is Function => typeof value === \"function\",\n  serialize: (callback: Function) => registerCallback(callback),\n  deserialize: deserializeCallbackId,\n};\n","import SuperJSON from \"superjson\";\nimport { abortSignalSerializer } from \"./abortSignal\";\nimport { callbackSerializer } from \"./callbacks\";\n\nexport const bridgeSerializer = new SuperJSON();\n\nbridgeSerializer.registerCustom(callbackSerializer, \"superbridge-callback\");\n\nbridgeSerializer.registerCustom(\n  abortSignalSerializer,\n  \"superbridge-abortSignal\"\n);\n","export default {}","const fs = require('fs');\nconst path = require('path');\n\nconst pathFile = path.join(__dirname, 'path.txt');\n\nfunction getElectronPath () {\n  let executablePath;\n  if (fs.existsSync(pathFile)) {\n    executablePath = fs.readFileSync(pathFile, 'utf-8');\n  }\n  if (process.env.ELECTRON_OVERRIDE_DIST_PATH) {\n    return path.join(process.env.ELECTRON_OVERRIDE_DIST_PATH, executablePath || 'electron');\n  }\n  if (executablePath) {\n    return path.join(__dirname, 'dist', executablePath);\n  } else {\n    throw new Error('Electron failed to install correctly, please delete node_modules/electron and try installing again');\n  }\n}\n\nmodule.exports = getElectronPath();\n","export interface PromiseController<T> {\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}\n\nexport function createControlledPromise<T>() {\n  let controller: PromiseController<T> | undefined;\n\n  const promise = new Promise<T>((_resolve, _reject) => {\n    controller = {\n      resolve: _resolve,\n      reject: _reject,\n    };\n  });\n\n  return [promise, controller!] as const;\n}\n","export function getIPCChannelName(name: string) {\n  return `SUPERBRIDGE__${name}`;\n}\n","import \"../shared/init\";\nimport \"../shared/superbridge\";\n\nimport { IpcMainInvokeEvent, ipcMain, webContents } from \"electron\";\nimport {\n  PromiseController,\n  createControlledPromise,\n} from \"../utils/controlledPromise\";\n\nimport { BridgeMessageType } from \"../shared/defineMessage\";\nimport { HandleResult } from \"../shared/messages\";\nimport { RawBridgeData } from \"../shared/types\";\nimport { bridgeSerializer } from \"../shared/serializer\";\nimport { createLogger } from \"../shared/log\";\nimport { generateId } from \"../utils/id\";\nimport { getIPCChannelName } from \"../shared/channel\";\nimport { initializeSuperbridge } from \"../shared/superbridge\";\n\nconst log = createLogger(\"superbridge/main/init\");\n\nconst pendingRequests = new Map<string, PromiseController<any>>();\n\nipcMain.handle(\n  getIPCChannelName(\"HANDLE_RESULT\"),\n  (_event, payload: RawBridgeData) => {\n    const result = bridgeSerializer.deserialize<HandleResult<any>>(\n      payload.payload\n    );\n\n    const pendingRequestController = pendingRequests.get(result.requestId);\n\n    if (!pendingRequestController) {\n      throw new Error(`No controller found for requestId: ${result.requestId}`);\n    }\n\n    pendingRequests.delete(result.requestId);\n\n    if (result.type === \"success\") {\n      pendingRequestController.resolve(result.result);\n    } else {\n      pendingRequestController.reject(result.error);\n    }\n  }\n);\n\ninitializeSuperbridge({\n  send<I, O>(message: BridgeMessageType<I, O>, payload: I, webId?: number) {\n    if (webId === undefined) {\n      throw new Error(\"webId is required\");\n    }\n\n    const requestId = generateId();\n\n    const targetWebContents = webContents.fromId(webId);\n\n    if (!targetWebContents) {\n      throw new Error(`Target webContents not found for id: ${webId}`);\n    }\n\n    log.debug(`Send \"${message.type}\" with payload`, payload);\n\n    const [promise, controller] = createControlledPromise<O>();\n\n    pendingRequests.set(requestId, controller);\n\n    targetWebContents.send(getIPCChannelName(message.type), {\n      requestId,\n      payload: bridgeSerializer.serialize(payload),\n    } as RawBridgeData);\n\n    return promise;\n  },\n  handle<I, O>(\n    message: BridgeMessageType<I, O>,\n    handler: (payload: I) => Promise<O>\n  ) {\n    async function handleMessage(\n      _event: IpcMainInvokeEvent,\n      payload: RawBridgeData\n    ) {\n      log.debug(`Handling \"${message.type}\" with payload`, payload);\n\n      const result = await handler(\n        bridgeSerializer.deserialize<I>(payload.payload)\n      );\n\n      return bridgeSerializer.serialize(result);\n    }\n\n    ipcMain.handle(getIPCChannelName(message.type), handleMessage);\n\n    return () => {\n      ipcMain.removeHandler(getIPCChannelName(message.type));\n    };\n  },\n});\n","import { defineBridgeMessage } from \"./defineMessage\";\n\nexport interface ExecuteMessageData {\n  id: string;\n  path: string;\n  args: unknown[];\n}\n\nexport type HandleResult<T> =\n  | {\n      requestId: string;\n      type: \"success\";\n      result: T;\n    }\n  | {\n      requestId: string;\n      type: \"error\";\n      error: string;\n    };\n\nexport const $execute = defineBridgeMessage<ExecuteMessageData, unknown>(\n  \"$execute\"\n);\n\nexport const $reset = defineBridgeMessage<void, void>(\"$reset\");\n","import { $execute, $reset } from \"../shared/messages\";\nimport { BridgeHandler, BridgeHandlerInput } from \"./BridgeHandler\";\n\nimport { bridge } from \"../shared/superbridge\";\nimport { createLogger } from \"../shared/log\";\n\nconst log = createLogger(\"superbridge/main/init\");\n\nexport function initializeSuperbridgeMain<T extends BridgeHandlerInput>(\n  handler: BridgeHandler<T>\n) {\n  log.debug(\"Initialize Superbridge Main\");\n\n  process.env.SUPERBRIDGE_SCHEMA = JSON.stringify(handler.schema);\n\n  bridge.handle($execute, async (payload) => {\n    log.debug(`Handling execute \"${payload.path}\" with args`, payload.args);\n    return handler.execute(payload.path, payload.args);\n  });\n\n  bridge.handle($reset, async () => {\n    log.debug(\"Handling reset\");\n    await handler.reset();\n  });\n}\n","const QUERY_SYMBOL = Symbol(\"query\");\n\nexport interface Query<Args extends unknown[] = unknown[], Result = unknown> {\n  (...args: Args): Promise<Result>;\n  [QUERY_SYMBOL]: \"query\";\n}\n\nexport function getIsQuery<Args extends unknown[], Result>(\n  value: unknown\n): value is Query<Args, Result> {\n  return (\n    typeof value === \"function\" &&\n    QUERY_SYMBOL in value &&\n    value[QUERY_SYMBOL] === \"query\"\n  );\n}\n\nexport function query<Args extends unknown[], Result>(\n  handler: (...args: Args) => Result\n): Query<Args, Result> {\n  const queryFunction: Query<Args, Result> = async (...args: Args) => {\n    return handler(...args);\n  };\n\n  queryFunction[QUERY_SYMBOL] = \"query\";\n\n  return queryFunction;\n}\n","const EFFECT_SYMBOL = Symbol(\"effect\");\n\ntype Cleanup = () => void;\ntype MaybePromise<T> = T | Promise<T>;\n\nexport interface Effect<Args extends unknown[] = unknown[]> {\n  (...args: Args): MaybePromise<Cleanup>;\n  [EFFECT_SYMBOL]: \"effect\";\n}\n\nexport function getIsEffect<Args extends unknown[]>(\n  value: unknown\n): value is Effect<Args> {\n  return (\n    typeof value === \"function\" &&\n    EFFECT_SYMBOL in value &&\n    value[EFFECT_SYMBOL] === \"effect\"\n  );\n}\n\nexport function effect<Args extends unknown[]>(\n  handler: (...args: Args) => MaybePromise<Cleanup>\n): Effect<Args> {\n  const effectFunction: Effect<Args> = async (...args: Args) => {\n    return handler(...args);\n  };\n\n  effectFunction[EFFECT_SYMBOL] = \"effect\";\n\n  return effectFunction;\n}\n","const MUTATION_SYMBOL = Symbol(\"mutation\");\n\nexport interface Mutation<\n  Args extends unknown[] = unknown[],\n  Result = unknown\n> {\n  (...args: Args): Promise<Result>;\n  [MUTATION_SYMBOL]: \"mutation\";\n}\n\nexport function getIsMutation<Args extends unknown[], Result>(\n  value: unknown\n): value is Mutation<Args, Result> {\n  return (\n    typeof value === \"function\" &&\n    MUTATION_SYMBOL in value &&\n    value[MUTATION_SYMBOL] === \"mutation\"\n  );\n}\n\nexport function mutation<Args extends unknown[], Result>(\n  handler: (...args: Args) => Result\n): Mutation<Args, Result> {\n  const mutationFunction: Mutation<Args, Result> = async (...args: Args) => {\n    return handler(...args);\n  };\n\n  mutationFunction[MUTATION_SYMBOL] = \"mutation\";\n\n  return mutationFunction;\n}\n","type PropertiesMapValue = unknown | NestedRecord;\n\ntype NestedRecord = {\n  [key: string]: PropertiesMapValue;\n};\n\nexport type PropertiesMap<LeafType = unknown> = Map<string, LeafType>;\n\n/**\n * Returns true only for plain, {} objects (not instances of classes, arrays, etc.)\n */\nfunction getIsPlainObject(value: unknown): value is Record<string, unknown> {\n  return value?.constructor === Object;\n}\n\nfunction getPath(currentPath: string, key: string) {\n  if (!currentPath) return key;\n\n  return `${currentPath}.${key}`;\n}\n\nfunction buildPropertiesMap<LeafType = unknown>(\n  currentPath: string,\n  result: PropertiesMap<LeafType>,\n  input: NestedRecord\n) {\n  for (const [key, value] of Object.entries(input)) {\n    const path = getPath(currentPath, key);\n\n    if (getIsPlainObject(value)) {\n      buildPropertiesMap(path, result, value);\n    } else {\n      result.set(path, value as LeafType);\n    }\n  }\n}\n\nexport function createNestedRecordPropertiesMap<LeafType = unknown>(\n  input: NestedRecord\n): PropertiesMap<LeafType> {\n  const map = new Map<string, LeafType>();\n\n  buildPropertiesMap(\"\", map, input);\n\n  return map;\n}\n\nfunction innerMapNestedRecord(\n  currentPath: string,\n  input: NestedRecord,\n  mapper: (value: unknown, path: string) => unknown\n): NestedRecord {\n  const result: NestedRecord = {};\n\n  for (const [key, value] of Object.entries(input)) {\n    const path = getPath(currentPath, key);\n\n    if (getIsPlainObject(value)) {\n      result[key] = innerMapNestedRecord(path, value, mapper);\n    } else {\n      result[key] = mapper(value, path);\n    }\n  }\n\n  return result;\n}\n\nexport function mapNestedRecord(\n  input: NestedRecord,\n  mapper: (value: unknown, path: string) => unknown\n): NestedRecord {\n  return innerMapNestedRecord(\"\", input, mapper);\n}\n\nexport function unwrapNestedRecord(\n  pathMap: Map<string, unknown> | Record<string, unknown>\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  // Convert to array of entries if input is a Map\n  const entries =\n    pathMap instanceof Map\n      ? Array.from(pathMap.entries())\n      : Object.entries(pathMap);\n\n  for (const [path, value] of entries) {\n    // Skip empty paths\n    if (!path) continue;\n\n    const keys = path.split(\".\");\n    let current = result;\n\n    // Navigate to the correct nesting level\n    for (let i = 0; i < keys.length - 1; i++) {\n      const key = keys[i];\n\n      // Create nested object if it doesn't exist\n      if (!(key in current)) {\n        current[key] = {};\n      }\n\n      // If the current value isn't an object, it will be overwritten\n      if (typeof current[key] !== \"object\" || current[key] === null) {\n        current[key] = {};\n      }\n\n      // Move to the next level\n      current = current[key] as Record<string, unknown>;\n    }\n\n    // Set the value at the final key\n    const lastKey = keys[keys.length - 1];\n    current[lastKey] = value;\n  }\n\n  return result;\n}\n","import { BridgeHandlerInput } from \"./BridgeHandler\";\nimport { createNestedRecordPropertiesMap } from \"../utils/nestedRecord\";\nimport { getIsEffect } from \"./effect\";\nimport { getIsMutation } from \"./mutation\";\nimport { getIsQuery } from \"./query\";\n\nexport type BridgeFieldSchema = {\n  type: \"query\" | \"mutation\" | \"effect\";\n};\n\nexport type BridgeHandlerSchema = Record<string, BridgeFieldSchema>;\n\nexport function getBridgeHandlerSchema(input: BridgeHandlerInput) {\n  const map = createNestedRecordPropertiesMap(input);\n\n  const schema: BridgeHandlerSchema = {};\n\n  for (const [key, value] of map.entries()) {\n    if (getIsQuery(value)) {\n      schema[key] = {\n        type: \"query\",\n      };\n      continue;\n    }\n\n    if (getIsMutation(value)) {\n      schema[key] = {\n        type: \"mutation\",\n      };\n      continue;\n    }\n\n    if (getIsEffect(value)) {\n      schema[key] = {\n        type: \"effect\",\n      };\n      continue;\n    }\n\n    if (typeof value === \"function\") {\n      schema[key] = {\n        type: \"query\",\n      };\n      continue;\n    }\n\n    console.warn(`Unknown field type: ${key}`, value);\n  }\n\n  return schema;\n}\n","import { BridgeHandlerSchema, getBridgeHandlerSchema } from \"./schema\";\nimport { Effect, getIsEffect } from \"./effect\";\nimport { Mutation, getIsMutation } from \"./mutation\";\n\nimport { MaybePromise } from \"../shared/types\";\nimport { Query } from \"./query\";\nimport { createLogger } from \"../shared/log\";\nimport { createNestedRecordPropertiesMap } from \"../utils/nestedRecord\";\n\nconst log = createLogger(\"superbridge/main/BridgeHandler\");\n\nexport type BridgeNestedObject<LeafType> = {\n  [key: string]: BridgeNestedObject<LeafType> | LeafType;\n};\n\ntype Cleanup = () => void;\n\nexport type BridgeSingleHandler =\n  | Query<any[], any>\n  | Mutation<any[], any>\n  | Effect<any[]>;\n\nexport type BridgeHandlerInput = BridgeNestedObject<BridgeSingleHandler>;\n\n// Define the handlersMap type separately to ensure it's preserved in declarations\nexport type BridgeHandlerMap = Map<string, BridgeSingleHandler>;\n\nexport class BridgeHandler<T extends BridgeHandlerInput> {\n  private handlersMap: BridgeHandlerMap = new Map();\n  public readonly schema: BridgeHandlerSchema;\n\n  constructor(public readonly input: T) {\n    this.handlersMap =\n      createNestedRecordPropertiesMap<BridgeSingleHandler>(input);\n    this.schema = getBridgeHandlerSchema(input);\n  }\n\n  private pendingMutations = new Set<Promise<unknown>>();\n  private runningEffects = new Set<MaybePromise<Cleanup>>();\n\n  private async waitForPendingMutations() {\n    while (this.pendingMutations.size) {\n      const promises = [...this.pendingMutations];\n\n      for (const promise of promises) {\n        try {\n          await promise;\n        } catch {}\n      }\n    }\n  }\n\n  private addPendingMutation(promise: Promise<unknown>) {\n    this.pendingMutations.add(promise);\n\n    promise.finally(() => {\n      this.pendingMutations.delete(promise);\n    });\n  }\n\n  private getHandler(path: string): BridgeSingleHandler {\n    const handler = this.handlersMap.get(path);\n\n    if (!handler) {\n      throw new Error(`Handler not found for path: ${path}`);\n    }\n\n    return handler;\n  }\n\n  async execute(path: string, args: unknown[]): Promise<unknown> {\n    const handler = this.getHandler(path);\n\n    if (getIsMutation(handler)) {\n      const promise = handler(...args);\n\n      this.addPendingMutation(promise);\n\n      return promise;\n    }\n\n    if (getIsEffect(handler)) {\n      const cleanup = handler(...args);\n\n      this.runningEffects.add(cleanup);\n\n      return cleanup;\n    }\n\n    return handler(...args);\n  }\n\n  async cleanAllEffects(): Promise<void> {\n    const effects = [...this.runningEffects];\n\n    for (const effect of effects) {\n      try {\n        const cleanup = await effect;\n\n        if (typeof cleanup === \"function\") {\n          cleanup();\n        }\n      } catch {}\n    }\n\n    this.runningEffects.clear();\n  }\n\n  async reset(): Promise<void> {\n    await this.cleanAllEffects();\n    await this.waitForPendingMutations();\n  }\n}\n\nexport function createBridgeHandler<T extends BridgeHandlerInput>(\n  input: T\n): BridgeHandler<T> {\n  return new BridgeHandler(input);\n}\n"],"names":["log","name","require$$0","ipcMain","webContents","path","effect"],"mappings":"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","x_google_ignoreList":[9]}