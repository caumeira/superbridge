{"version":3,"file":"index.cjs","sources":["../../utils/Signal.ts","../../shared/superbridge.ts","../../shared/defineMessage.ts","../../utils/id.ts","../../shared/serializer/abortSignal.ts","../../shared/log.ts","../../shared/serializer/callbacks.ts","../../shared/serializer/index.ts","../../client/init.ts","../../shared/messages.ts","../../utils/nestedRecord.ts","../../client/createClient.ts"],"sourcesContent":["type Listener<T> = (value: T) => void;\n\ntype Cleanup = () => void;\n\nconst NO_VALUE = Symbol(\"NO_VALUE\");\n\nexport class Signal<T> {\n  private listeners = new Map<Symbol, Listener<T>>();\n  private lastValue: T | typeof NO_VALUE = NO_VALUE;\n\n  assertLastValue(error: Error | string) {\n    if (this.lastValue === NO_VALUE) {\n      throw typeof error === \"string\" ? new Error(error) : error;\n    }\n\n    return this.lastValue;\n  }\n\n  get hasLastValue() {\n    return this.lastValue !== NO_VALUE;\n  }\n\n  get maybeLastValue() {\n    return this.lastValue === NO_VALUE ? undefined : this.lastValue;\n  }\n\n  emit(value: T) {\n    this.lastValue = value;\n\n    const listeners = [...this.listeners.values()];\n\n    for (const listener of listeners) {\n      try {\n        listener(value);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n\n  subscribe(listener: Listener<T>) {\n    const id = Symbol();\n\n    this.listeners.set(id, listener);\n\n    return () => {\n      this.listeners.delete(id);\n    };\n  }\n\n  subscribeWithCurrentValue(listener: Listener<T>) {\n    if (this.lastValue !== NO_VALUE) {\n      listener(this.lastValue);\n    }\n\n    return this.subscribe(listener);\n  }\n\n  effect(initializer: (value: T) => Cleanup) {\n    let currentCleanup: Cleanup | undefined;\n\n    const cancelSubscription = this.subscribeWithCurrentValue((value) => {\n      if (currentCleanup) {\n        currentCleanup();\n      }\n\n      currentCleanup = initializer(value);\n    });\n\n    return () => {\n      cancelSubscription();\n\n      if (currentCleanup) {\n        currentCleanup();\n      }\n    };\n  }\n}\n","import { BridgeMessageType } from \"./defineMessage\";\nimport { Signal } from \"../utils/Signal\";\n\ntype Cancel = () => void;\n\nexport interface SuperbridgeLink {\n  send<I, O>(\n    message: BridgeMessageType<I, O>,\n    payload: I,\n    webId?: number\n  ): Promise<O>;\n\n  handle<I, O>(\n    message: BridgeMessageType<I, O>,\n    handler: (payload: I) => Promise<O>\n  ): Cancel;\n}\n\nconst currentSuperbridgeChannel = new Signal<SuperbridgeLink>();\n\nexport function initializeSuperbridge(superbridge: SuperbridgeLink) {\n  currentSuperbridgeChannel.emit(superbridge);\n}\n\nexport const bridge: SuperbridgeLink = {\n  send<I, O>(message: BridgeMessageType<I, O>, payload: I, webId?: number) {\n    const link = currentSuperbridgeChannel.assertLastValue(\n      \"Superbridge is not initialized\"\n    );\n\n    return link.send(message, payload, webId);\n  },\n  handle<I, O>(\n    message: BridgeMessageType<I, O>,\n    handler: (payload: I) => Promise<O>\n  ) {\n    if (!currentSuperbridgeChannel.hasLastValue) {\n      Promise.resolve().then(() => {\n        if (!currentSuperbridgeChannel.hasLastValue) {\n          console.warn(\"Superbridge is not initialized\");\n        }\n      });\n    }\n    return currentSuperbridgeChannel.effect((currentBridge) => {\n      return currentBridge.handle(message, handler);\n    });\n  },\n};\n","export class BridgeMessageType<I, O> {\n  constructor(public readonly type: string) {}\n\n  input!: I;\n  output!: O;\n}\n\nexport function defineBridgeMessage<I, O = void>(\n  name: string\n): BridgeMessageType<I, O> {\n  return new BridgeMessageType<I, O>(name);\n}\n","const ALPHABET =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\nexport function generateId(length: number = 12) {\n  let id = \"\";\n\n  for (let i = 0; i < length; i++) {\n    id += ALPHABET[Math.floor(Math.random() * ALPHABET.length)];\n  }\n\n  return id;\n}\n","import { CustomTransfomer } from \"./types\";\nimport { bridge } from \"../superbridge\";\nimport { defineBridgeMessage } from \"../defineMessage\";\nimport { generateId } from \"../../utils/id\";\n\nconst signalRemoteController = new Map<string, AbortController>();\n\nexport const $abortRemoteSignal = defineBridgeMessage<{\n  signalId: string;\n}>(\"$abortRemoteSignal\");\n\nexport function registerSignal(localSignal: AbortSignal) {\n  const id = `$$signal-${generateId()}`;\n  const remoteController = new AbortController();\n\n  signalRemoteController.set(id, remoteController);\n\n  // If local signal is aborted, abort the remote one\n  localSignal.addEventListener(\"abort\", () => {\n    bridge.send($abortRemoteSignal, { signalId: id });\n    signalRemoteController.delete(id);\n  });\n\n  signalFinalizationRegistry.register(localSignal, id);\n\n  return id;\n}\n\nbridge.handle($abortRemoteSignal, async ({ signalId }) => {\n  const controller = signalRemoteController.get(signalId);\n\n  if (!controller) return;\n\n  controller.abort();\n  signalRemoteController.delete(signalId);\n});\n\nconst signalFinalizationRegistry = new FinalizationRegistry<string>(\n  (remoteSignalId) => {\n    const controller = signalRemoteController.get(remoteSignalId);\n\n    if (!controller) return;\n\n    controller.abort();\n    signalRemoteController.delete(remoteSignalId);\n  }\n);\n\nfunction deserializeSignalId(signalId: string): AbortSignal {\n  const controller = new AbortController();\n\n  signalRemoteController.set(signalId, controller);\n\n  return controller.signal;\n}\n\nexport const abortSignalSerializer: CustomTransfomer<AbortSignal, string> = {\n  isApplicable: (value): value is AbortSignal => value instanceof AbortSignal,\n  serialize: (signal: AbortSignal) => registerSignal(signal),\n  deserialize: (signalId: string) => deserializeSignalId(signalId),\n};\n","type Log = (...args: any[]) => void;\n\ninterface Logger {\n  (...args: any[]): void;\n  debug: Log;\n  warn: Log;\n  error: Log;\n  rename: (name: string) => Logger;\n}\n\nexport function createLogger(name: string): Logger {\n  const LOG_COLOR = \"#808080\";\n  const LOG_STYLE = `color: ${LOG_COLOR};`;\n\n  const LABEL = `%cðŸŒ‰ ${name}:%c`;\n\n  const log: Logger = (...args) => {\n    console.info(LABEL, LOG_STYLE, \"\", ...args);\n  };\n\n  log.debug = (...args) => {\n    console.debug(LABEL, LOG_STYLE, \"\", ...args);\n  };\n\n  log.warn = (...args) => {\n    console.warn(LABEL, LOG_STYLE, \"\", ...args);\n  };\n\n  log.error = (...args) => {\n    console.error(LABEL, LOG_STYLE, \"\", ...args);\n  };\n\n  log.rename = (name: string) => {\n    return createLogger(name);\n  };\n\n  return log;\n}\n\nexport const log = createLogger(\"superbridge\");\n","import { CustomTransfomer } from \"./types\";\nimport { bridge } from \"../superbridge\";\nimport { createLogger } from \"../log\";\nimport { defineBridgeMessage } from \"../defineMessage\";\nimport { generateId } from \"../../utils/id\";\n\nconst log = createLogger(\"superbridge/callbacks\");\n\nconst callbacks = new Map<string, Function>();\n\nexport const $removeRemoteCallback = defineBridgeMessage<{\n  callbackId: string;\n}>(\"$removeRemoteCallback\");\n\nexport const $triggerRemoteCallback = defineBridgeMessage<\n  {\n    callbackId: string;\n    args: unknown[];\n  },\n  unknown\n>(\"$triggerRemoteCallback\");\n\nbridge.handle($removeRemoteCallback, async ({ callbackId }) => {\n  log.debug(`Handling remove remote callback \"${callbackId}\"`);\n  callbacks.delete(callbackId);\n});\n\nbridge.handle($triggerRemoteCallback, async ({ callbackId, args }) => {\n  log.debug(\n    `Handling trigger remote callback \"${callbackId}\" with callId`,\n    args\n  );\n  const callback = callbacks.get(callbackId);\n\n  if (!callback) {\n    throw new Error(`Callback \"${callbackId}\" not found`);\n  }\n\n  return await callback(...args);\n});\n\nfunction getCallbackId() {\n  let id = `$$callback-${generateId()}`;\n\n  if (typeof window !== \"undefined\") {\n    id = `${id}-${window.$superbridgeinterface.routingId}`;\n  }\n\n  return id;\n}\n\n/**\n * $$callback-123-456\n */\nfunction getCallbackRoutingId(callbackId: string) {\n  const [_callbackLabel, _callbackId, routingId] = callbackId.split(\"-\");\n\n  if (!routingId) return null;\n\n  return parseInt(routingId, 10);\n}\n\nexport function registerCallback(callback: Function) {\n  const id = getCallbackId();\n\n  callbacks.set(id, callback);\n\n  return id;\n}\n\nconst callbackFinalizationRegistry = new FinalizationRegistry<string>(\n  (remoteCallbackId) => {\n    bridge.send(\n      $removeRemoteCallback,\n      { callbackId: remoteCallbackId },\n      getCallbackRoutingId(remoteCallbackId) ?? undefined\n    );\n  }\n);\n\nfunction deserializeCallbackId(callbackId: string) {\n  async function remoteCallbackInvoker(...args: unknown[]) {\n    log.debug(`Invoking remote callback \"${callbackId}\" with args`, args);\n\n    return await bridge.send(\n      $triggerRemoteCallback,\n      {\n        callbackId: callbackId,\n        args,\n      },\n      getCallbackRoutingId(callbackId) ?? undefined\n    );\n  }\n\n  callbackFinalizationRegistry.register(remoteCallbackInvoker, callbackId);\n\n  return remoteCallbackInvoker;\n}\n\nexport const callbackSerializer: CustomTransfomer<Function, string> = {\n  isApplicable: (value): value is Function => typeof value === \"function\",\n  serialize: (callback: Function) => registerCallback(callback),\n  deserialize: deserializeCallbackId,\n};\n","import SuperJSON from \"superjson\";\nimport { abortSignalSerializer } from \"./abortSignal\";\nimport { callbackSerializer } from \"./callbacks\";\n\nexport const bridgeSerializer = new SuperJSON();\n\nbridgeSerializer.registerCustom(callbackSerializer, \"superbridge-callback\");\n\nbridgeSerializer.registerCustom(\n  abortSignalSerializer,\n  \"superbridge-abortSignal\"\n);\n","import \"../shared/init\";\n\nimport { BridgeMessageType } from \"../shared/defineMessage\";\nimport { HandleResult } from \"../shared/messages\";\nimport { bridgeSerializer } from \"../shared/serializer\";\nimport { generateId } from \"../utils/id\";\nimport { initializeSuperbridge } from \"../shared/superbridge\";\n\nconst { $superbridgeinterface } = window;\n\ninitializeSuperbridge({\n  async send<I, O>(\n    message: BridgeMessageType<I, O>,\n    payload: I,\n    webId?: number\n  ) {\n    if (webId !== undefined) {\n      console.warn(\n        \"Sending message to specific webContents is not supported in the client\"\n      );\n      webId = undefined;\n    }\n\n    const requestId = generateId();\n\n    const result = await $superbridgeinterface.send(message.type, {\n      requestId,\n      payload: bridgeSerializer.serialize(payload),\n    });\n\n    return bridgeSerializer.deserialize(result) as O;\n  },\n  handle<I, O>(\n    message: BridgeMessageType<I, O>,\n    handler: (payload: I) => Promise<O>\n  ) {\n    return $superbridgeinterface.handle(\n      message.type,\n      async ({ requestId, payload }) => {\n        try {\n          const result = await handler(\n            bridgeSerializer.deserialize(payload) as I\n          );\n\n          await $superbridgeinterface.send(\"HANDLE_RESULT\", {\n            requestId,\n            payload: bridgeSerializer.serialize({\n              requestId,\n              type: \"success\",\n              result,\n            } as HandleResult<O>),\n          });\n        } catch (error) {\n          await $superbridgeinterface.send(\"HANDLE_RESULT\", {\n            requestId,\n            payload: bridgeSerializer.serialize({\n              requestId,\n              type: \"error\",\n              error,\n            } as HandleResult<O>),\n          });\n        }\n      }\n    );\n  },\n});\n","import { defineBridgeMessage } from \"./defineMessage\";\n\nexport interface ExecuteMessageData {\n  id: string;\n  path: string;\n  args: unknown[];\n}\n\nexport type HandleResult<T> =\n  | {\n      requestId: string;\n      type: \"success\";\n      result: T;\n    }\n  | {\n      requestId: string;\n      type: \"error\";\n      error: string;\n    };\n\nexport const $execute = defineBridgeMessage<ExecuteMessageData, unknown>(\n  \"$execute\"\n);\n\nexport const $reset = defineBridgeMessage<void, void>(\"$reset\");\n","type PropertiesMapValue = unknown | NestedRecord;\n\ntype NestedRecord = {\n  [key: string]: PropertiesMapValue;\n};\n\nexport type PropertiesMap<LeafType = unknown> = Map<string, LeafType>;\n\n/**\n * Returns true only for plain, {} objects (not instances of classes, arrays, etc.)\n */\nfunction getIsPlainObject(value: unknown): value is Record<string, unknown> {\n  return value?.constructor === Object;\n}\n\nfunction getPath(currentPath: string, key: string) {\n  if (!currentPath) return key;\n\n  return `${currentPath}.${key}`;\n}\n\nfunction buildPropertiesMap<LeafType = unknown>(\n  currentPath: string,\n  result: PropertiesMap<LeafType>,\n  input: NestedRecord\n) {\n  for (const [key, value] of Object.entries(input)) {\n    const path = getPath(currentPath, key);\n\n    if (getIsPlainObject(value)) {\n      buildPropertiesMap(path, result, value);\n    } else {\n      result.set(path, value as LeafType);\n    }\n  }\n}\n\nexport function createNestedRecordPropertiesMap<LeafType = unknown>(\n  input: NestedRecord\n): PropertiesMap<LeafType> {\n  const map = new Map<string, LeafType>();\n\n  buildPropertiesMap(\"\", map, input);\n\n  return map;\n}\n\nfunction innerMapNestedRecord(\n  currentPath: string,\n  input: NestedRecord,\n  mapper: (value: unknown, path: string) => unknown\n): NestedRecord {\n  const result: NestedRecord = {};\n\n  for (const [key, value] of Object.entries(input)) {\n    const path = getPath(currentPath, key);\n\n    if (getIsPlainObject(value)) {\n      result[key] = innerMapNestedRecord(path, value, mapper);\n    } else {\n      result[key] = mapper(value, path);\n    }\n  }\n\n  return result;\n}\n\nexport function mapNestedRecord(\n  input: NestedRecord,\n  mapper: (value: unknown, path: string) => unknown\n): NestedRecord {\n  return innerMapNestedRecord(\"\", input, mapper);\n}\n\nexport function unwrapNestedRecord(\n  pathMap: Map<string, unknown> | Record<string, unknown>\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  // Convert to array of entries if input is a Map\n  const entries =\n    pathMap instanceof Map\n      ? Array.from(pathMap.entries())\n      : Object.entries(pathMap);\n\n  for (const [path, value] of entries) {\n    // Skip empty paths\n    if (!path) continue;\n\n    const keys = path.split(\".\");\n    let current = result;\n\n    // Navigate to the correct nesting level\n    for (let i = 0; i < keys.length - 1; i++) {\n      const key = keys[i];\n\n      // Create nested object if it doesn't exist\n      if (!(key in current)) {\n        current[key] = {};\n      }\n\n      // If the current value isn't an object, it will be overwritten\n      if (typeof current[key] !== \"object\" || current[key] === null) {\n        current[key] = {};\n      }\n\n      // Move to the next level\n      current = current[key] as Record<string, unknown>;\n    }\n\n    // Set the value at the final key\n    const lastKey = keys[keys.length - 1];\n    current[lastKey] = value;\n  }\n\n  return result;\n}\n","import \"./init\";\nimport { type BridgeHandler, BridgeHandlerInput } from \"../main/BridgeHandler\";\nimport { Effect } from \"../main/effect\";\nimport { Mutation } from \"../main/mutation\";\nimport { Query } from \"../main/query\";\nimport { createLogger } from \"../shared/log\";\nimport { $execute, $reset } from \"../shared/messages\";\nimport { generateId } from \"../utils/id\";\nimport { unwrapNestedRecord } from \"../utils/nestedRecord\";\nimport { bridge } from \"../shared/superbridge\";\n\nconst CLIENT_SYMBOL = Symbol(\"superbridge-client\");\n\nconst log = createLogger(\"superbridge/client\");\n\ntype Cleanup = () => void;\n\ntype QueryClient<Args extends any[], Result> = (\n  ...args: Args\n) => Promise<Awaited<Result>>;\n\ntype MutationClient<Args extends any[], Result> = (\n  ...args: Args\n) => Promise<Awaited<Result>>;\n\ntype EffectClient<Args extends any[]> = (...args: Args) => Cleanup;\n\ntype SuperbridgeClientValue<T> = T extends Query<infer Args, infer Result>\n  ? QueryClient<Args, Result>\n  : T extends Mutation<infer Args, infer Result>\n  ? MutationClient<Args, Result>\n  : T extends Effect<infer Args>\n  ? EffectClient<Args>\n  : T extends BridgeHandlerInput\n  ? SuperbridgeClient<T>\n  : never;\n\nexport type SuperbridgeClient<T extends BridgeHandlerInput> = {\n  [K in keyof T]: SuperbridgeClientValue<T[K]>;\n};\n\nfunction createQueryClient<Args extends any[], Result>(path: string) {\n  return async function query(...args: Args): Promise<Awaited<Result>> {\n    log.debug(`Query \"${path}\" with args`, args);\n    await resetPromise;\n\n    return bridge.send($execute, {\n      id: generateId(),\n      path,\n      args,\n    }) as Promise<Awaited<Result>>;\n  };\n}\n\nfunction createMutationClient<Args extends any[], Result>(path: string) {\n  return async function mutation(...args: Args): Promise<Awaited<Result>> {\n    log.debug(`Mutation \"${path}\" with args`, args);\n    await resetPromise;\n\n    return bridge.send($execute, {\n      id: generateId(),\n      path,\n      args,\n    }) as Promise<Awaited<Result>>;\n  };\n}\n\nfunction createEffectClient<Args extends any[]>(path: string) {\n  return function effect(...args: Args) {\n    log.debug(`Effect \"${path}\" with args`, args);\n    const maybeCleanupPromise = resetPromise.then(() =>\n      bridge.send($execute, {\n        id: generateId(),\n        path,\n        args,\n      })\n    );\n\n    return async function cleanup() {\n      try {\n        const cleanup = await maybeCleanupPromise;\n\n        if (typeof cleanup === \"function\") {\n          cleanup();\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    };\n  };\n}\n\nlet resetPromise: Promise<void>;\n\nexport function createSuperbridgeClient<\n  T extends BridgeHandler<any>\n>(): SuperbridgeClient<T[\"input\"]> {\n  resetPromise = bridge.send($reset, undefined);\n\n  const schema = window.$superbridgeinterface.schema;\n\n  if (!schema) {\n    throw new Error(\"Schema is not initialized\");\n  }\n\n  const flatClient: Record<string, any> = {};\n\n  for (const [path, fieldSchema] of Object.entries(schema)) {\n    if (fieldSchema.type === \"query\") {\n      flatClient[path] = createQueryClient(path);\n    }\n\n    if (fieldSchema.type === \"mutation\") {\n      flatClient[path] = createMutationClient(path);\n    }\n\n    if (fieldSchema.type === \"effect\") {\n      flatClient[path] = createEffectClient(path);\n    }\n  }\n\n  const client = unwrapNestedRecord(flatClient) as SuperbridgeClient<\n    T[\"input\"]\n  >;\n\n  Reflect.set(client, CLIENT_SYMBOL, true);\n\n  return client;\n}\n"],"names":["log","name","cleanup"],"mappings":"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"}